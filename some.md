我们知道在Android系统中，Zygote进程负责启动系统服务进程SystemServer，而系统服务进程SystemServer负责启动系统中的各种关键服务，例如我们在前面两篇文章Android应用程序安装过程源代码分析和Android系统默认Home应用程序（Launcher）的启动过程源代码分析中提到的Package管理服务PackageManagerService和Activity管理服务ActivityManagerService。这里我们所讨论的窗口管理服务WindowManagerService也是由SystemServer来启动的，具体的启动过程这里就不再详述了，具体可以参考PackageManagerService和ActivityManagerService的启动过程。

什么要规定所有与UI相关的操作都必须在主线程中执行呢？我们知道，这些与UI相关的操作都涉及到大量的控件内部状态以及需要访问窗口的绘图表面，也就是说，要大量地访问控件类的成员变量以及窗口绘图表面里面的图形缓冲区，因此，如果不将这些与UI相关的操作限定在同一个线程中执行的话，那么就会涉及到线程同步问题。线程同步的开销是很大的，因此，就要保证那些与UI相关的操作都在同一个线程中执行。这个负责执行UI相关操作的线程便是应用程序进程的主线程，因此我们也将应用程序进程的主线程称为UI线程。
那么，有没有办法让某一个控件的UI享有独立的图形缓冲区呢？也就是这个控件不将自己的UI数据填入到它的宿主窗口的绘图表面的图形缓冲区里面去。如果可以的话，那么我们就可以在另外一个独立的线程中绘制该控件的UI。这样做的好处是显而易见——可以在这个独立的线程执行相对比较耗时的UI绘制操作而不会导致主线程无法及时响应用户输入。答案是肯定的，在接下来的一篇文章中，我们就分析一个可以具有独立图形缓冲区的控件——SurfaceView。

Inflate(resId , null ) 只创建temp ,返回temp
Inflate(resId , parent, false )创建temp，然后执行temp.setLayoutParams(params);返回temp
Inflate(resId , parent, true ) 创建temp，然后执行root.addView(temp, params);最后返回root